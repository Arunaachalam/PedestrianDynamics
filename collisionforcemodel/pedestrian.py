#*********************************************************************************
# CLASS Pedestrian - A Class with Variables for Individual Pedestrians
#*********************************************************************************

import numpy as np

class Pedestrian():
    def __init__(self,id):
        # Standard Parameters for Pedestrians
        self.radius = 0.25
        self.mass = 75.0

        self.id = id                        # Unique id generated by Code
        self.desired_velocity = 0.0           # Preferred Velocity given as input
        self.maximum_velocity = 0.0           # Maximum Velocity given as input
        self.target_point = [0,0]           # Target Point given as input
        self.position = [0,0]               # Position of Pedestrian
        self.velocity = [0,0]               # Velocity of the pedestrian

        self.average_velocity = [0,0]       # Average Velocity of the World
        self.lambda_f = 1.0                 # Lambda for Preferred Force Calculation (set at 1)

        self.total_force = [0,0]            # Total force on Pedestrian
        self.prefered_force = [0,0]         # Preferred force on Pedestrian (calculated in Class:World)
        self.repulsive_force = [0,0]        # Repulsive force on Pedestrian (calculated in Class:World)
        self.wall_force = [0,0]             # Wall force on Pedestrian (calculated in Class:World)
        self.wall_point = [0,0]             # The Nearest Wall to Pedestrian

        self.direction = 0                  # Target 1 = x_axis, 2 = y_axis
        self.temp_velocity = [0,0]

    #---------------------------------------------------------------------------------------
    #***************** Setter Functions for Class Variables*********************************
    #---------------------------------------------------------------------------------------
    def set_mass(self,mass):
        self.mass = mass

    def set_radius(self,radius):
        self.radius = radius

    def set_desiredvelocity(self,desired_velocity):
        self.desired_velocity = desired_velocity

    def set_maximumvelocity(self,maximum_velocity):
        self.maximum_velocity = maximum_velocity

    def set_targetpoint(self,target_point):
        self.target_point = target_point

    def set_position(self,position):
        self.position = position

    def set_averagevelocity(self,velocity):
        self.average_velocity = velocity

    def set_preferedforce(self,force):
        self.prefered_force = force

    def set_repulsiveforce(self,force):
        self.repulsive_force = force

    def set_wallforce(self,force):
        self.wall_force = force

    def set_wallpoint(self,point):
        self.wall_point = point

    def set_direction(self,direc):
        self.direction = direc

    #---------------------------------------------------------------------------------------
    #********************** Functions for Calculation***************************************
    #---------------------------------------------------------------------------------------

    #Velocity set based on Preferred Direction and Maximum Velocity
    def set_velocity(self):
        dir = np.subtract(self.target_point,self.position)
        desired_dir = dir/np.linalg.norm(dir)
        self.velocity = np.multiply(desired_dir,self.maximum_velocity)
        self.temp_velocity = self.velocity

    # Set Forces to Zero after each Timestep
    def set_zeroforce(self):
        self.total_force = [0,0]
        self.repulsive_force = [0,0]
        self.prefered_force = [0,0]

    # Calculate Total Force by adding other forces F_prefered, F_wall, and F_repulsive
    def calculate_force(self):
        self.total_force = self.prefered_force+self.repulsive_force+self.wall_force

    # ERROR CHECK: Usage statistically low: Correct position if the position is out of bound
    def correct_position(self):
        if self.direction == 1:
            if not self.position[1] < 15 and self.position[1] > 10:
                if self.position[1] < 10:
                    self.position[1] = self.wall_point[1]+0.1
                if self.position[1] > 15:
                    self.position[1] = self.wall_point[1]-0.1
        if self.direction == 2:
            if not self.position[0] < 15 and self.position[1] > 10:
                if self.position[0] < 10:
                    self.position[0] = self.wall_point[0]+0.1
                if self.position[0] > 15:
                    self.position[0] = self.wall_point[0]-0.1

    # Update Velocity of Pedestrian v(t) = v(t-1) + dt*F
    def update_velocity(self,timestep):
        self.calculate_force()
        self.velocity = np.add(self.velocity,np.multiply(self.total_force,timestep))
        norm_value = np.linalg.norm(self.velocity)
        self.velocity = np.multiply(self.velocity/norm_value,min(norm_value,self.maximum_velocity))


    # Update Position of pedestrian x(t) = x(t-1) + dt*v
    def update_position(self,timestep):
        self.position = np.add(self.position,np.multiply(self.velocity, timestep))
        self.correct_position()


